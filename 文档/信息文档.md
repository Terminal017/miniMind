### 一、RAG 检索增强

1、**RAG（检索增强生成）**：就是**检索（Retrieval） + 生成（Generation）**

2、RAG 负责解决大模型表现不佳的问题：

- **幻觉问题**：它会一本正经地胡说八道（记忆模糊）。
- **时效性差**：它的知识停留在训练结束的那一刻（比如 2024 年的信息它可能不知道）。

3、RAG 的标准工作流：

- **加载（Load）**：导入你的私有文档（PDF、Markdown、数据库记录等）。
- **切片（Split）**：把长文章切成小段（chunk），方便精准定位。
- **向量化（Embed）**：通过 Embedding 模型把文字转成一串数字（向量），捕捉语义（离线构造向量数据库，包含向量加原文 chunk）。
- **检索（Retrieve）**：当用户提问时，系统先去向量数据库里找最相关的片段。
- **增强（Augment）**：把找到的片段和用户的问题一起喂给 LLM。
- **生成（Generate）**：LLM 根据提供的参考资料，给出准确的答案。

### 二、Orama

1、[Orama](https://orama.com/)：一个用 TypeScript 编写的开源、极速、全文本及向量搜索引擎。它可以运行在任何地方，包括浏览器、Node.js、甚至是在边缘计算节点（如 Cloudflare Workers）。

2、Orama 特性：

- 它支持传统的关键词搜索（Full-text search）和向量搜索（Vector search），可以用于 RAG。
- 包含多种功能：语义搜索（embedding），结构化字段过滤，排序、评分、聚合等
- 轻量且性能极高，是为了毫秒级响应而设计的
- 可以分布式部署

### 三、WebGPU

1、**WebGPU**：是新一代的 Web 图形和计算标准。是 Web 上的 **GPGPU（通用 GPU 计算）** 接口。可以提供并行计算能力（比如用来进行矩阵乘法）

2、与浏览器里和 GPU 相关概念：

- WebGL：Web GPU 前身，用来画图
- WebAssembly：用来跑 CPU 密集型任务
- 它们都不适合进行通用并行计算

### 四、Transformers.js

1、[Transformers.js](https://huggingface.co/docs/transformers.js/index)：让 Transformer 模型能在浏览器和 Node.js 中运行的推理框架，是开源库。可用于在浏览器中跑轻量模型。

2、框架特性：

- 支持文本（分类、翻译、摘要、LLM）、音频（Whisper 语音识别）、图像（目标检测、分割）等数百种模型。
- **ONNX 驱动**：它底层使用了 **ONNX Runtime Web**。它会将 PyTorch 或 TensorFlow 模型转换成 ONNX 格式，然后通过 WebGPU 加速运行。

3、与 WebGPU 协作：调用 Transformer.js 框架时，Transformers.js 识别到环境支持 WebGPU，将计算任务交给显卡。

### 五、ONNX Runtime

1、**ONNX Runtime (ORT)** ：是由微软开发的跨平台高性能推理引擎。核心目标是让同一套模型能在任何硬件上跑得飞快。它提供标准化（**ONNX 格式，模型中间表示格式**），无论模型是用 PyTorch、TensorFlow 还是 JAX 训练的，都可以转换成 `.onnx` 格式提供给硬件。ORT 通过优化计算图，优化内存调度实现高速度。

2、ORT 能作为执行提供商（Execution Providers），自动识别环境并调用最合适的加速接口：

- 在浏览器里：调用 **WebGPU** 或 **WASM**。这种场景下使用的是 ONNX Runtime Web，提供 WASM（CPU）和 WebGPU（GPU）。
- 在 Windows 上：调用 **DirectML**。
- 在 Linux/服务器上：调用 **CUDA** 或 **TensorRT**。

3、与 Transformers.js 的关系：

- Transformers.js 负责前置工作，比如文本切片等，将需要高性能的工作（比如数学推理）交给 ONNX Runtime 处理。
- Transformer.js 会调用 ONNX Runtime 完成高性能工作，并在此之上提供模型接口与任务逻辑
- Transformers.js 会根据用户的浏览器环境，动态让 ONNX Runtime 选择用 WebGPU（极速）还是 WASM（高兼容）。

### 六、LangChain.js

1、**LangChain.js**：LLM 应用编排框架，[LangChain](https://www.langchain.com/)的 JavaScript/TypeScript 版本，用于构建一个完整的 AI 系统，专门为了 Web 开发环境进行了优化。

2、LangChain.js 包含以下核心组件：

- **Models（模型适配器）**：连接不同的 LLM（如 OpenAI、Gemini）
- **Prompts（模板）**：管理复杂的提示词结构。
- **Indexes & Retrievers（检索增强）**：可以调用 Orama 作为向量存储
- **Chains（链）**：将多个步骤串联。例如：`用户输入 -> 检索 Orama 数据库 -> 提示词增强 -> 本地模型推理`。
- **Agents（智能体）**：让 LLM 具备“决策”能力，决定是否要去查文档、算数学题或调用 API。

### 七、IndexedDB

1、**IndexedDB**：浏览器内置的一种非关系型数据库（NoSQL）。用于存储大量、结构化、且长期存在的数据，通常可以存储几百 MB-几 GB 的数据。
参考：[MDN IndexedDB 文档](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API)

2、IndexedDB 特性：

- 存储数据量大，可以存储`Transformers.js` 下载的模型（几百 MB），PDF 文档，向量数据等
- 离线存储，在浏览器关闭后依旧可以保存
- 直接存储 JS 对象，无需转化为 JSON
- 操作为**异步操作**，并且支持事务操作
- 缺陷：基于事件回调（非 Promise），原生 API 设计相当古老，难以使用。

3、存储结构：

- Database：命名空间，一个域名下可以创建多个数据库，不同数据库独立
- Object Store：对象仓库，具体存储数据记录的地方（类似 Mongo DB 的集合）
- Object / Record（官方）：文档数据，通常是键值对，每条记录必须有一个唯一的键（key），value 可以是任何 JS 可克隆对象（通常是 JS 对象）。
- key：主键，可以是 number / string / Date / Array。key 既可以在值外面（键值对），也可以在里面（类似`_id`）
- Index：索引，一种辅助存储结构。添加索引后，数据库会额外维护一个有序的列表，记录索引与主键的关系，方便通过索引快速查询。
  存储图例：

```
Database -> Store(设置value) -> Record(key,value)
```

### 八、Dexie.js

1、[Dexie.js](https://dexie.org/) ：是 IndexedDB 的高层封装库，将 IndexedDB 的底层逻辑包装成了**Promise/Async-Await** 风格。

2、Dexie.js 封装特性：

- 极简代码设计和提供数据库升级机制
- 支持链式调用
- 支持类似 React 状态管理的功能：如果数据库数据发生变化，可以同步更新 UI

### 九、Web Worker

1、**Web Worker**：用于在浏览器后台创建一个独立的线程，执行那些耗时的计算任务，而完全不影响主线程的 UI 渲染（因为 JS 是单线程的）。
参考：[MDN Web Worker API 文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers)

2、Web Worker 的特性：

- 运行在独立线程中，拥有独立的工作域，没有 DOM 和 window
- 限制：默认的通信方式为消息传递，非常繁琐。主线程和 Worker 之间不能共享 JS 对象，只能通过监听 `onmessage`获取，通过`postMessage`传递。

### 十、Comlink

1、**Comlink**：Google Chrome 团队开发的极轻量级的库（约 1KB），JavaScript 的 **Proxy（代理）** 特性，将主线程与 Worker 间的消息传递封装成函数调用。

2、Comlink 与 Web Worker 通信的区别：

- Web Worker 通信只能依赖`postMessage`，消息是 **单向、异步、无状态**。
- Comlink 用 Proxy 把消息协议封装成远程对象调用，开发体验就是函数调用。

### 十一、Zustand

1、[Zustand](https://zustand.docs.pmnd.rs/getting-started/introduction)：一个轻量、快速、且基于 Hooks 的状态管理库。核心特性是极简配置。

2、Zustand 相对于其他状态管理的优势：

- Zustand 非常简洁，只需要定义一个 store 即可，也不会强制用 `Provider` 包裹整个 App
- Redux Toolkit 有非常繁琐的样板
- React Context 通常会导致全量渲染

3、Zustand 全局状态管理库特性：

- 原生支持异步
- 通过“订阅制”工作，仅关心的数据变了，才会重新渲染对应组件。
- 可以在 **任何地方** 获取或修改状态，不一定要在 React 组件内
- 拥有多功能中间件，比如 Persist (自动持久化)进行自动存入 LocalStorage，Immer 中间用于处理复杂嵌套

### 十二、PDF、markdown 和代码解析库

1、**pdfjs-dist**：Mozilla 的 PDF.js 的底层核心库，用于在浏览器端处理 PDF，现在是解析 PDF 的“行业标准”。它在 JavaScript 中实现了一套 PDF 渲染与解析引擎。

2、**gray-matter**：JS 库，用于解析 Frontmatter 元数据。很多 Markdown 文件开头都有由 `---` 包围的 YAML 信息（如：标题、标签、日期）。这个库会把这些信息提取成一个 JS 对象，把剩下的正文提取成字符串。

3、**remark**：JS 库，用于把 Markdown 文本解析成 AST（抽象语法树）

- AST 特性：可以遍历这棵树，精确地找到所有的 `heading`（标题）、`list`（列表）、`code`（代码块）。
- 非常适合后续操作，例如按标题级别来切分文档
