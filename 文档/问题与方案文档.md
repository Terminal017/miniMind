1. 自定义 shadcn/ui 组件覆盖问题：

- 采用 cn()函数设置 className

2. Web Worker 实例存放位置选择：Zustand 全局还是组件内：

- 存放在 Zustand 全局可以让其他组件调用同一个 Web Worker，并且在组件卸载后 Web Worker 还能继续工作。
- 不同类型工作使用不同的 Web Worker，避免模型下载（长任务）卡住文档切片（短任务）

3、组件 Dialog 中添加 form 会扰乱样式：

- 使用关联表单
- React19 使用 action 传函数以代替 onSubmit

4、删除项渲染顺序问题：在确认后自动关闭确认框时，确认数据先发生更改再关闭。（原因是 useLiveQuery 实时响应数据库变化，在数据库变化后实时响应）

- 增加新的 state，用于保存数据快照，并触发渲染

5、跨域问题（核心）：通常`<script>`允许跨域加载，但是 Web Worker 的脚本必须与调用它的页面同源。加载 PDF.js 包时默认自动允许新 Worker 的脚本不同源，

- 将包中的 Worker 脚本拷贝到 public 本地实现同源

6、Web Worker 挂载静默失败（原因存疑）：

- Web Worker 创建流程：下载 worker 脚本 -> 执行 ESM -> 执行所有顶层代码（import，其他副作用）-> 如果失败，Worker 会静默失败（且一般情况下，worker 的错误不会冒泡到主线程，导致没有错误信息）
- 错误原因：在导入 unified 这类包时，它们可能存在访问 Node API 的代码，worker 又在独立的环境中，导致导入时运行失败，结果就是 worker 解析失败。**事实上，它们是专为 Node 环境设计的包，本身不支持纯浏览器使用**
- 解决方案：避免导入这些不适用于 Worker 环境的包，部分改为手写解析

7、Web Worker 打包错误（核心）：worker 中导入的包无法找到路径

- 问题分析：Web worker 的运行环境是浏览器中的独立环境，无法读取/node_modules 中的包
- 解决方案：使用 esbuild 提前打包 web worker 及其依赖到 public 中

8、连续调用 toast 会超出最大渲染更新栈

- 问题分析：toast 是同步 API，内部使用 flushSync 进行同步更新，传入的值会被拷贝，仅保存那一次的快照（即使传入 state 也不会因此改变，只能重新调用 toast）
- 解决方案：通过 Zustand 管理模型状态更新而非在父组件内，Progress 组件通过 Zustand 管理状态并渲染，不会重新渲染 toast。
