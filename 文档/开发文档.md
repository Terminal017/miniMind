### 全局开发

1、初始化项目，添加所有依赖和工具，包括：

- dexie.js：IndexedDB 的高层封装库，用于优化 Indexed DB 操作
- shadcn/ui：现代 UI 库
- lucide-react：轻量级 React 图标库
- clsx：动态类名构建库，用于优化 tailwind 原子类拼接
- tailwind-merge：tailwind 相关库，用于 tailwind 原子类合并，配合 clsx 使用

2、使用 Zustand 创建全局状态 store，包括：

- 模型加载状态（WebGPU 支持、模型下载状态、模型下载进度）
- Web Worker 状态（Web Worker 实例、通信代理、初始化函数、清理函数）

3、Web Worker 设计：

- worker 实例和通信代理均放在 Zustand 全局状态中，避免组件重复渲染时可能发生的重复创建带来额外消耗。由于 worker 绑定的是 JS 模块，当 worker 绑定在 Zustand 全局状态中后，切换路由后仍在生命周期内，不会卸载。
- 主线程通过存放在 Zustand 中的 Comlink.wrap 调用 Web Worker
- doc-worker 用于文章解析、切片、向量化，同一个 Worker 内进行可以减少传输压力。

### IndexDB 数据库设计

1、数据库 miniMindDB：

- 表 library：存放知识库相关信息
- 表 docs：存放文档信息
- 表 chunks：存放切片信息

2、表 library：

```
id: number //id（主键）
name: string //名称
createdAt: Date //创建日期
updatedAt: Date //更新日期
files: number //文件数量
chunks: number //切片数量
```

3、表 docs：

```
id: number //id（主键）
libraryId: number //所属知识库 id（外键）
name: string //文档名称
rawText: string //文档解析额后的纯文本内容
size: number //解析后的文件大小，用于展示
status: string //文档状态（切片中、解析中）
createdAt: Date //创建日期
```

4、表 chunks：

```
id: number //id（主键）
docId: number //所属文档 ID（外键）
libraryId: number //所属知识库 ID（外键）
content: string //切片文本内容
embedding: number[] //向量表示
```

### knowledge 页面

1、UI 开发：

- Nav 导航栏组件：使用 shadcn/ui 的 Button 组件和 Next 的 Link
- 知识库页面卡片列表组件：使用 grid + shadcn/ui 的 Card 组件
- 确认提示组件：shadcn/ui 的 Alert Dialog 组件
- 添加新知识库的表单组件：shadcn/ui 的 Dialog 组件
- 操作完成/失败提示：shadcn/ui 的 Toast(sonner)组件
- 文档表格：shadcn/ui 的 Table 组件基础上配合 tanstack 开发，多选框 checkBox 组件
- 返回上页链接组件：shadcn/ui 的 breadcrumb 组件
- 模型下载和文件处理进度条：shadcn/ui 的 toast + Progress 组件

2、功能开发：

- 显示知识库和文档具体信息： 数据存 Indexed DB 中
- 新建/删除知识库： 基础 CRUD
- 新建/删除/批量删除文档
- 批量导入文件：使用一个隐藏的 input(type="file")，绑定 button 按钮触发 input 的点击事件进行处理。使用 useRef 让 input 成为受控组件
- 在 Web Worker 中解析文本、PDF、markdown（浏览器主线程只适合读取纯文本，解析 PDF 等复杂工作适合放在 worker 中进行）
- 在 Web Worker 中进行切片：使用`'@langchain/textsplitters'`的`RecursiveCharacterTextSplitter,MarkdownTextSplitter`分别处理文本和 markdown 切片，对代码做单独切分。

3、重要开发：

1. 向量化模型下载和进度条：

- 在 Web Worker 中，通过 Transformers.js 下载模型`Xenova/bge-small-zh-v1.5`，并启用 Web GPU
- 模型下载进度由 pipeline 函数提供的高频回调函数从 worker 中返回，主线程需要将获取进度并修改状态的回调函数以 Comlink.Proxy 传入 worker。
- 回调函数最初设计为直接为直接获取数据并采用统一 id 的 toast 进行渲染更新，并为考虑性能问题设计了节流，但是 toast 内部发生了 React 渲染栈调用过多的问题，官方文档显示不建议频繁调用 toast。尝试采用 useEffect 触发渲染，但 toast 是同步更新的，更新外部 state 不会更新 toast。
- 最终考虑让 Progress 组件自己管理状态，并使用 Zustand 存储状态。这样可以在不干涉 toast 的情况下更新进度条状态，且用户切换路由也能正常下载。

2. 向量化设计：使用平均池化和归一化进行优化

- 向量化含义：把人类语言映射到一个高维的数学空间中。在这个空间里，语义相近的句子，它们在空间里的距离就越近。
- 平均池化：向量化模型在对一句话进行向量化时，会把它们拆分成 token 并分别进行向量化，然后生成`[词数, 512]`这样的结果。**平均池化就是把所有 Token 对应位置的数值加起来，然后除以 Token 数量**。
- 归一化：判断两个向量距离的方法需要计算两个向量之间的角度，默认的余弦公式需要计算的数据很大（因为需要计算向量长度），**归一化就是强行把所有向量的长度（模长）压缩/拉伸到 1**（这样余弦公式就相当于点积）
